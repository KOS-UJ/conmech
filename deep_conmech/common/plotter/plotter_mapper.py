import time

from deep_conmech.common import config, mapper
from deep_conmech.common.plotter import plotter_3d
from deep_conmech.common.plotter.plotter_2d import Plotter
from deep_conmech.graph.helpers import thh
from deep_conmech.graph.model import *
from deep_conmech.simulator.setting.setting_forces import *


def print_setting(setting, filename, catalog):
    cmh.create_folders(catalog)
    extension = "png"  # pdf
    path = f"{catalog}/{filename}.{extension}"
    print_setting_internal(setting, path, None, extension, 0, True)


def print_dataset(dataset, cutoff, timestamp, description):
    print(f"Printing dataset {description}...")
    dataloader = get_print_dataloader(dataset)
    batch = next(iter(dataloader))
    iterations = np.min([len(batch), cutoff])
    for i in range(iterations):
        print_setting(batch.setting[i], i, timestamp, description)

        # for _ in range(100):
        #    setting.set_forces(np.random.uniform(
        #        low= -config.FORCES_DATA_SCALE,
        #        high= config.FORCES_DATA_SCALE,
        #        size=(setting.nodes_count, dim)
        #    ))
        #    test_setting(setting)
        #    a = setting.calculate_normalized()
        #    setting.iterate(a)
        # break


############################


def print_one_dynamic(
    solve_function, scenario, catalog, simulate_dirty_data, draw_base, draw_detailed, description
):
    all_images_paths = []
    extension = "png"  # pdf
    cmh.create_folders(f"output/{catalog}")

    _print_at_interval = lambda time, setting, base_setting, a, base_a: print_at_interval(
        time,
        setting,
        f"output/{catalog}/{scenario.id} {int(time * 100)}.{extension}",
        base_setting if draw_base else None,
        draw_detailed,
        all_images_paths,
        extension,
    )

    mapper.map_time(
        draw_base,
        _print_at_interval,
        solve_function,
        scenario,
        simulate_dirty_data,
        description,
    )

    Plotter.draw_animation(
        f"output/{catalog}/{scenario.id} scale_{scenario.scale} ANIMATION.gif", all_images_paths
    )


def print_at_interval(time, setting, path, base_setting, draw_detailed, all_images_paths, extension):
    if nph.skip(time, config.PRINT_SKIP):
        print_setting_internal(setting, path, base_setting, extension, time, draw_detailed)
        all_images_paths.append(path)


def print_setting_internal(setting, path, base_setting, extension, time, draw_detailed):
    if setting.dim == 2:
        plotter = Plotter()
        ax = plotter.get_one_ax()
        plotter.draw_setting_ax(setting, ax, base_setting, time, draw_detailed)
        plotter.plt_save(path, extension)
    else:
        plotter_3d.plot_frame(
            setting=setting,
            normalized_data=[
                setting.normalized_forces * 20,
                setting.normalized_u_old,
                setting.normalized_v_old,
                setting.normalized_a_old,
            ],
            path=path,
            extension=extension,
        )
        plotter_3d.plt_save(path, extension)


def print_setting_test(setting):
    plotter = Plotter()
    ax = plotter.get_one_ax()
    plotter.draw_displaced(setting, [0.0, 0.0], "orange", ax)
    plotter.plt_save("./output/1.png", "png")


###############################


def print_multiple_dynamic(get_a_function, description=None):
    plots = 4
    time_steps = 5
    skip = 10

    plotter = Plotter()
    axs = plotter.get_multiple_axs(plots, time_steps)
    unit = config.DRAW_FORCE_UNIT

    print_steps(plotter, axs, 0, time_steps, skip, [0.0, unit], get_a_function)
    print_steps(plotter, axs, 1, time_steps, skip, [0.0, -unit], get_a_function)
    print_steps(plotter, axs, 2, time_steps, skip, [unit, 0.0], get_a_function)
    print_steps(plotter, axs, 3, time_steps, skip, [-unit, 0.0], get_a_function)

    ts = time.time()
    name = f"draw_mesh - {description} - {ts}"
    # writer.add_figure(f"OUTPUT/{name}", plt.gcf())

    plotter.plt_save(name)


def print_steps(drawer, axs, row, time_steps, skip, force, get_a_function):
    # TODO: Get data generated by Data
    setting = SolverTorch(mesh_type=config.MESH_TYPE, mesh_density=config.MESH_DENSITY)

    forces = np.repeat([force], setting.nodes_count, axis=0)
    setting.set_forces(forces)

    for time in range(time_steps * skip):
        a = get_a_function(setting)
        setting.iterate(a)
        if time % skip == 0:
            drawer.draw_setting_ax(setting, axs[row, int(i / skip)], time=time)


###############################


def print_test():
    plotter = Plotter()
    mesh = Mesh(mesh_type=config.MESH_TYPE, mesh_density=2)
    # Assert
    # np.around(np.mean(mesh.features[:,:,0], axis=1),4) = 0
    # np.around(np.mean(mesh.features[:,:,1], axis=1),4) = 0
    plotter.draw_data_triangles(mesh, mesh.cells_points, mesh.features[:, :, 0:2])
    plotter.draw_colors_triangles(mesh, mesh.features)
    plotter.draw_data_edges(mesh, mesh.edges_points, mesh.edges_features[:, 0:2])

    # self.draw_data_edges(mesh, mesh.edges_points, mesh.W11)

