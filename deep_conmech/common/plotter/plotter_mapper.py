import time
from deep_conmech.common.plotter.plotter_basic import Plotter
from deep_conmech.common import mapper, config
from deep_conmech.graph.model import *
from deep_conmech.simulator.setting.setting_forces import *


def print_setting(setting, filename, catalog):
    basic_helpers.create_folders(catalog)
    extension = "png"  # pdf
    path = f"{catalog}/{filename}.{extension}"
    print_setting_internal(setting, path, None, extension, 0)


def print_dataset(dataset, cutoff, timestamp, description):
    print(f"Printing dataset {description}...")
    dataloader = get_print_dataloader(dataset)
    batch = next(iter(dataloader))
    iterations = np.min([len(batch), cutoff])
    for i in range(iterations):
        print_setting(batch.setting[i], i, timestamp, description)

        # for _ in range(100):
        #    setting.set_forces(np.random.uniform(
        #        low= -config.FORCES_DATA_SCALE,
        #        high= config.FORCES_DATA_SCALE,
        #        size=(setting.nodes_count, config.DIM)
        #    ))
        #    test_setting(setting)
        #    a = setting.calculate_normalized()
        #    setting.iterate(a)
        # break


############################


def print_one_dynamic(
    solve_function, scenario, catalog, simulate_dirty_data, print_base, description
):
    plotter = Plotter()
    all_images_paths = []
    extension = "png"  # pdf
    basic_helpers.create_folders(f"output/{catalog}")

    _print_at_interval = lambda time, setting, base_setting, a, base_a: print_at_interval(
        time,
        setting,
        f"output/{catalog}/{scenario.id} {int(time * 100)}.{extension}",
        base_setting if print_base else None,
        all_images_paths,
        extension,
    )

    mapper.map_time(
        print_base,
        _print_at_interval,
        config.VAL_PRINT_EPISODE_STEPS,
        solve_function,
        scenario,
        simulate_dirty_data,
        description,
    )

    plotter.draw_animation(
        f"output/{catalog}/{scenario.id} ANIMATION.gif", all_images_paths
    )


def print_at_interval(time, setting, path, base_setting, all_images_paths, extension):
    if basic_helpers.skip(time, config.PRINT_SKIP):
        print_setting_internal(setting, path, base_setting, extension, time)
        all_images_paths.append(path)


def print_setting_internal(setting, path, base_setting, extension, time):
    plotter = Plotter()
    ax = plotter.get_one_ax()
    height = 1 if base_setting is None else 2
    plotter.draw_setting_ax(setting, ax, [3, height, 12, 3], base_setting, time)
    plotter.plt_save(path, extension)


###############################


def print_multiple_dynamic(get_a_function, description=None):
    plots = 4
    time_steps = 5
    skip = 10

    plotter = Plotter()
    axs = plotter.get_multiple_axs(plots, time_steps)
    unit = config.DRAW_FORCE_UNIT

    print_steps(plotter, axs, 0, time_steps, skip, [0.0, unit], get_a_function)
    print_steps(plotter, axs, 1, time_steps, skip, [0.0, -unit], get_a_function)
    print_steps(plotter, axs, 2, time_steps, skip, [unit, 0.0], get_a_function)
    print_steps(plotter, axs, 3, time_steps, skip, [-unit, 0.0], get_a_function)

    ts = time.time()
    name = f"draw_mesh - {description} - {ts}"
    # writer.add_figure(f"OUTPUT/{name}", plt.gcf())

    plotter.plt_save(name)


def print_steps(drawer, axs, row, time_steps, skip, force, get_a_function):
    # TODO: Get data generated by Data
    setting = SolverTorch(mesh_type=config.MESH_TYPE, mesh_density=config.MESH_DENSITY)

    forces = np.repeat([force], setting.nodes_count, axis=0)
    setting.set_forces(forces)

    for time in range(time_steps * skip):
        a = get_a_function(setting)
        setting.iterate(a)
        if time % skip == 0:
            drawer.draw_setting_ax(
                setting, axs[row, int(i / skip)], boundaries=[1, 1, 1, 1], time=time
            )


"""
def draw_one_dynamic(self, model, description):
    mesh = Mesh(mesh_type=config.MESH_TYPE, mesh_density=config.MESH_SIZE_PRINT)
    setting = SolverDynamic(mesh)

    force =basic_helpers.to_torch_float([config.DRAW_FORCE_ONE])
    forces_at_time = torch.repeat_interleave(force, mesh.nodes_count, axis=0)

    self.draw_mesh(mesh)

    for i in range(100):
        x = torch.hstack((forces_at_time, setting.u_old_torch, setting.v_old_torch))
        v = self.predict(mesh, model, x)
        setting.iterate(v)
        if i % 20 == 0:
            self.draw_mesh(mesh, description)
"""


###############################


def print_test():
    plotter = Plotter()
    mesh = Mesh(mesh_type=config.MESH_TYPE, mesh_density=2)
    # Assert
    # np.around(np.mean(mesh.features[:,:,0], axis=1),4) = 0
    # np.around(np.mean(mesh.features[:,:,1], axis=1),4) = 0
    plotter.draw_data_triangles(mesh, mesh.cells_points, mesh.features[:, :, 0:2])
    plotter.draw_colors_triangles(mesh, mesh.features)
    plotter.draw_data_edges(mesh, mesh.edges_points, mesh.edges_features[:, 0:2])

    # self.draw_data_edges(mesh, mesh.edges_points, mesh.W11)

